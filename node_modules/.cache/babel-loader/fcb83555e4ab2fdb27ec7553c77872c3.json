{"ast":null,"code":"/*! @preserve\r\n * bootbox.js\r\n * version: 5.3.2\r\n * author: Nick Payne <nick@kurai.co.uk>\r\n * license: MIT\r\n * http://bootboxjs.com/\r\n */\n(function (root, factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['jquery'], factory);\n  } else if (typeof exports === 'object') {\n    // Node, CommonJS-like\n    module.exports = factory(require('jquery'));\n  } else {\n    // Browser globals (root is window)\n    root.bootbox = factory(root.jQuery);\n  }\n})(this, function init($, undefined) {\n  'use strict'; //  Polyfills Object.keys, if necessary.\n  //  @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n\n  if (!Object.keys) {\n    Object.keys = function () {\n      var hasOwnProperty = Object.prototype.hasOwnProperty,\n          hasDontEnumBug = !{\n        toString: null\n      }.propertyIsEnumerable('toString'),\n          dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],\n          dontEnumsLength = dontEnums.length;\n      return function (obj) {\n        if (typeof obj !== 'function' && (typeof obj !== 'object' || obj === null)) {\n          throw new TypeError('Object.keys called on non-object');\n        }\n\n        var result = [],\n            prop,\n            i;\n\n        for (prop in obj) {\n          if (hasOwnProperty.call(obj, prop)) {\n            result.push(prop);\n          }\n        }\n\n        if (hasDontEnumBug) {\n          for (i = 0; i < dontEnumsLength; i++) {\n            if (hasOwnProperty.call(obj, dontEnums[i])) {\n              result.push(dontEnums[i]);\n            }\n          }\n        }\n\n        return result;\n      };\n    }();\n  }\n\n  var exports = {};\n  var VERSION = '5.0.0';\n  exports.VERSION = VERSION;\n  var locales = {\n    ar: {\n      OK: 'موافق',\n      CANCEL: 'الغاء',\n      CONFIRM: 'تأكيد'\n    },\n    bg_BG: {\n      OK: 'Ок',\n      CANCEL: 'Отказ',\n      CONFIRM: 'Потвърждавам'\n    },\n    br: {\n      OK: 'OK',\n      CANCEL: 'Cancelar',\n      CONFIRM: 'Sim'\n    },\n    cs: {\n      OK: 'OK',\n      CANCEL: 'Zrušit',\n      CONFIRM: 'Potvrdit'\n    },\n    da: {\n      OK: 'OK',\n      CANCEL: 'Annuller',\n      CONFIRM: 'Accepter'\n    },\n    de: {\n      OK: 'OK',\n      CANCEL: 'Abbrechen',\n      CONFIRM: 'Akzeptieren'\n    },\n    el: {\n      OK: 'Εντάξει',\n      CANCEL: 'Ακύρωση',\n      CONFIRM: 'Επιβεβαίωση'\n    },\n    en: {\n      OK: 'OK',\n      CANCEL: 'Cancel',\n      CONFIRM: 'OK'\n    },\n    es: {\n      OK: 'OK',\n      CANCEL: 'Cancelar',\n      CONFIRM: 'Aceptar'\n    },\n    eu: {\n      OK: 'OK',\n      CANCEL: 'Ezeztatu',\n      CONFIRM: 'Onartu'\n    },\n    et: {\n      OK: 'OK',\n      CANCEL: 'Katkesta',\n      CONFIRM: 'OK'\n    },\n    fa: {\n      OK: 'قبول',\n      CANCEL: 'لغو',\n      CONFIRM: 'تایید'\n    },\n    fi: {\n      OK: 'OK',\n      CANCEL: 'Peruuta',\n      CONFIRM: 'OK'\n    },\n    fr: {\n      OK: 'OK',\n      CANCEL: 'Annuler',\n      CONFIRM: 'Confirmer'\n    },\n    he: {\n      OK: 'אישור',\n      CANCEL: 'ביטול',\n      CONFIRM: 'אישור'\n    },\n    hu: {\n      OK: 'OK',\n      CANCEL: 'Mégsem',\n      CONFIRM: 'Megerősít'\n    },\n    hr: {\n      OK: 'OK',\n      CANCEL: 'Odustani',\n      CONFIRM: 'Potvrdi'\n    },\n    id: {\n      OK: 'OK',\n      CANCEL: 'Batal',\n      CONFIRM: 'OK'\n    },\n    it: {\n      OK: 'OK',\n      CANCEL: 'Annulla',\n      CONFIRM: 'Conferma'\n    },\n    ja: {\n      OK: 'OK',\n      CANCEL: 'キャンセル',\n      CONFIRM: '確認'\n    },\n    ka: {\n      OK: 'OK',\n      CANCEL: 'გაუქმება',\n      CONFIRM: 'დადასტურება'\n    },\n    ko: {\n      OK: 'OK',\n      CANCEL: '취소',\n      CONFIRM: '확인'\n    },\n    lt: {\n      OK: 'Gerai',\n      CANCEL: 'Atšaukti',\n      CONFIRM: 'Patvirtinti'\n    },\n    lv: {\n      OK: 'Labi',\n      CANCEL: 'Atcelt',\n      CONFIRM: 'Apstiprināt'\n    },\n    nl: {\n      OK: 'OK',\n      CANCEL: 'Annuleren',\n      CONFIRM: 'Accepteren'\n    },\n    no: {\n      OK: 'OK',\n      CANCEL: 'Avbryt',\n      CONFIRM: 'OK'\n    },\n    pl: {\n      OK: 'OK',\n      CANCEL: 'Anuluj',\n      CONFIRM: 'Potwierdź'\n    },\n    pt: {\n      OK: 'OK',\n      CANCEL: 'Cancelar',\n      CONFIRM: 'Confirmar'\n    },\n    ru: {\n      OK: 'OK',\n      CANCEL: 'Отмена',\n      CONFIRM: 'Применить'\n    },\n    sk: {\n      OK: 'OK',\n      CANCEL: 'Zrušiť',\n      CONFIRM: 'Potvrdiť'\n    },\n    sl: {\n      OK: 'OK',\n      CANCEL: 'Prekliči',\n      CONFIRM: 'Potrdi'\n    },\n    sq: {\n      OK: 'OK',\n      CANCEL: 'Anulo',\n      CONFIRM: 'Prano'\n    },\n    sv: {\n      OK: 'OK',\n      CANCEL: 'Avbryt',\n      CONFIRM: 'OK'\n    },\n    sw: {\n      OK: 'Sawa',\n      CANCEL: 'Ghairi',\n      CONFIRM: 'Thibitisha'\n    },\n    ta: {\n      OK: 'சரி',\n      CANCEL: 'ரத்து செய்',\n      CONFIRM: 'உறுதி செய்'\n    },\n    th: {\n      OK: 'ตกลง',\n      CANCEL: 'ยกเลิก',\n      CONFIRM: 'ยืนยัน'\n    },\n    tr: {\n      OK: 'Tamam',\n      CANCEL: 'İptal',\n      CONFIRM: 'Onayla'\n    },\n    uk: {\n      OK: 'OK',\n      CANCEL: 'Відміна',\n      CONFIRM: 'Прийняти'\n    },\n    zh_CN: {\n      OK: 'OK',\n      CANCEL: '取消',\n      CONFIRM: '确认'\n    },\n    zh_TW: {\n      OK: 'OK',\n      CANCEL: '取消',\n      CONFIRM: '確認'\n    }\n  };\n  var templates = {\n    dialog: '<div class=\"bootbox modal\" tabindex=\"-1\" role=\"dialog\" aria-hidden=\"true\">' + '<div class=\"modal-dialog\">' + '<div class=\"modal-content\">' + '<div class=\"modal-body\"><div class=\"bootbox-body\"></div></div>' + '</div>' + '</div>' + '</div>',\n    header: '<div class=\"modal-header\">' + '<h5 class=\"modal-title\"></h5>' + '</div>',\n    footer: '<div class=\"modal-footer\"></div>',\n    closeButton: '<button type=\"button\" class=\"bootbox-close-button close\" aria-hidden=\"true\">&times;</button>',\n    form: '<form class=\"bootbox-form\"></form>',\n    button: '<button type=\"button\" class=\"btn\"></button>',\n    option: '<option></option>',\n    promptMessage: '<div class=\"bootbox-prompt-message\"></div>',\n    inputs: {\n      text: '<input class=\"bootbox-input bootbox-input-text form-control\" autocomplete=\"off\" type=\"text\" />',\n      textarea: '<textarea class=\"bootbox-input bootbox-input-textarea form-control\"></textarea>',\n      email: '<input class=\"bootbox-input bootbox-input-email form-control\" autocomplete=\"off\" type=\"email\" />',\n      select: '<select class=\"bootbox-input bootbox-input-select form-control\"></select>',\n      checkbox: '<div class=\"form-check checkbox\"><label class=\"form-check-label\"><input class=\"form-check-input bootbox-input bootbox-input-checkbox\" type=\"checkbox\" /></label></div>',\n      radio: '<div class=\"form-check radio\"><label class=\"form-check-label\"><input class=\"form-check-input bootbox-input bootbox-input-radio\" type=\"radio\" name=\"bootbox-radio\" /></label></div>',\n      date: '<input class=\"bootbox-input bootbox-input-date form-control\" autocomplete=\"off\" type=\"date\" />',\n      time: '<input class=\"bootbox-input bootbox-input-time form-control\" autocomplete=\"off\" type=\"time\" />',\n      number: '<input class=\"bootbox-input bootbox-input-number form-control\" autocomplete=\"off\" type=\"number\" />',\n      password: '<input class=\"bootbox-input bootbox-input-password form-control\" autocomplete=\"off\" type=\"password\" />',\n      range: '<input class=\"bootbox-input bootbox-input-range form-control-range\" autocomplete=\"off\" type=\"range\" />'\n    }\n  };\n  var defaults = {\n    // default language\n    locale: 'en',\n    // show backdrop or not. Default to static so user has to interact with dialog\n    backdrop: 'static',\n    // animate the modal in/out\n    animate: true,\n    // additional class string applied to the top level dialog\n    className: null,\n    // whether or not to include a close button\n    closeButton: true,\n    // show the dialog immediately by default\n    show: true,\n    // dialog container\n    container: 'body',\n    // default value (used by the prompt helper)\n    value: '',\n    // default input type (used by the prompt helper)\n    inputType: 'text',\n    // switch button order from cancel/confirm (default) to confirm/cancel\n    swapButtonOrder: false,\n    // center modal vertically in page\n    centerVertical: false,\n    // Append \"multiple\" property to the select when using the \"prompt\" helper\n    multiple: false,\n    // Automatically scroll modal content when height exceeds viewport height\n    scrollable: false\n  }; // PUBLIC FUNCTIONS\n  // *************************************************************************************************************\n  // Return all currently registered locales, or a specific locale if \"name\" is defined\n\n  exports.locales = function (name) {\n    return name ? locales[name] : locales;\n  }; // Register localized strings for the OK, Confirm, and Cancel buttons\n\n\n  exports.addLocale = function (name, values) {\n    $.each(['OK', 'CANCEL', 'CONFIRM'], function (_, v) {\n      if (!values[v]) {\n        throw new Error('Please supply a translation for \"' + v + '\"');\n      }\n    });\n    locales[name] = {\n      OK: values.OK,\n      CANCEL: values.CANCEL,\n      CONFIRM: values.CONFIRM\n    };\n    return exports;\n  }; // Remove a previously-registered locale\n\n\n  exports.removeLocale = function (name) {\n    if (name !== 'en') {\n      delete locales[name];\n    } else {\n      throw new Error('\"en\" is used as the default and fallback locale and cannot be removed.');\n    }\n\n    return exports;\n  }; // Set the default locale\n\n\n  exports.setLocale = function (name) {\n    return exports.setDefaults('locale', name);\n  }; // Override default value(s) of Bootbox.\n\n\n  exports.setDefaults = function () {\n    var values = {};\n\n    if (arguments.length === 2) {\n      // allow passing of single key/value...\n      values[arguments[0]] = arguments[1];\n    } else {\n      // ... and as an object too\n      values = arguments[0];\n    }\n\n    $.extend(defaults, values);\n    return exports;\n  }; // Hides all currently active Bootbox modals\n\n\n  exports.hideAll = function () {\n    $('.bootbox').modal('hide');\n    return exports;\n  }; // Allows the base init() function to be overridden\n\n\n  exports.init = function (_$) {\n    return init(_$ || $);\n  }; // CORE HELPER FUNCTIONS\n  // *************************************************************************************************************\n  // Core dialog function\n\n\n  exports.dialog = function (options) {\n    if ($.fn.modal === undefined) {\n      throw new Error('\"$.fn.modal\" is not defined; please double check you have included ' + 'the Bootstrap JavaScript library. See http://getbootstrap.com/javascript/ ' + 'for more details.');\n    }\n\n    options = sanitize(options);\n\n    if ($.fn.modal.Constructor.VERSION) {\n      options.fullBootstrapVersion = $.fn.modal.Constructor.VERSION;\n      var i = options.fullBootstrapVersion.indexOf('.');\n      options.bootstrap = options.fullBootstrapVersion.substring(0, i);\n    } else {\n      // Assuming version 2.3.2, as that was the last \"supported\" 2.x version\n      options.bootstrap = '2';\n      options.fullBootstrapVersion = '2.3.2';\n      console.warn('Bootbox will *mostly* work with Bootstrap 2, but we do not officially support it. Please upgrade, if possible.');\n    }\n\n    var dialog = $(templates.dialog);\n    var innerDialog = dialog.find('.modal-dialog');\n    var body = dialog.find('.modal-body');\n    var header = $(templates.header);\n    var footer = $(templates.footer);\n    var buttons = options.buttons;\n    var callbacks = {\n      onEscape: options.onEscape\n    };\n    body.find('.bootbox-body').html(options.message); // Only attempt to create buttons if at least one has \n    // been defined in the options object\n\n    if (getKeyLength(options.buttons) > 0) {\n      each(buttons, function (key, b) {\n        var button = $(templates.button);\n        button.data('bb-handler', key);\n        button.addClass(b.className);\n\n        switch (key) {\n          case 'ok':\n          case 'confirm':\n            button.addClass('bootbox-accept');\n            break;\n\n          case 'cancel':\n            button.addClass('bootbox-cancel');\n            break;\n        }\n\n        button.html(b.label);\n        footer.append(button);\n        callbacks[key] = b.callback;\n      });\n      body.after(footer);\n    }\n\n    if (options.animate === true) {\n      dialog.addClass('fade');\n    }\n\n    if (options.className) {\n      dialog.addClass(options.className);\n    }\n\n    if (options.size) {\n      // Requires Bootstrap 3.1.0 or higher\n      if (options.fullBootstrapVersion.substring(0, 3) < '3.1') {\n        console.warn('\"size\" requires Bootstrap 3.1.0 or higher. You appear to be using ' + options.fullBootstrapVersion + '. Please upgrade to use this option.');\n      }\n\n      switch (options.size) {\n        case 'small':\n        case 'sm':\n          innerDialog.addClass('modal-sm');\n          break;\n\n        case 'large':\n        case 'lg':\n          innerDialog.addClass('modal-lg');\n          break;\n\n        case 'xl':\n        case 'extra-large':\n          // Requires Bootstrap 4.2.0 or higher\n          if (options.fullBootstrapVersion.substring(0, 3) < '4.2') {\n            console.warn('Using size \"xl\"/\"extra-large\" requires Bootstrap 4.2.0 or higher. You appear to be using ' + options.fullBootstrapVersion + '. Please upgrade to use this option.');\n          }\n\n          innerDialog.addClass('modal-xl');\n          break;\n      }\n    }\n\n    if (options.scrollable) {\n      // Requires Bootstrap 4.3.0 or higher\n      if (options.fullBootstrapVersion.substring(0, 3) < '4.3') {\n        console.warn('Using \"scrollable\" requires Bootstrap 4.3.0 or higher. You appear to be using ' + options.fullBootstrapVersion + '. Please upgrade to use this option.');\n      }\n\n      innerDialog.addClass('modal-dialog-scrollable');\n    }\n\n    if (options.title) {\n      body.before(header);\n      dialog.find('.modal-title').html(options.title);\n    }\n\n    if (options.closeButton) {\n      var closeButton = $(templates.closeButton);\n\n      if (options.title) {\n        if (options.bootstrap > 3) {\n          dialog.find('.modal-header').append(closeButton);\n        } else {\n          dialog.find('.modal-header').prepend(closeButton);\n        }\n      } else {\n        closeButton.prependTo(body);\n      }\n    }\n\n    if (options.centerVertical) {\n      // Requires Bootstrap 4.0.0-beta.3 or higher\n      if (options.fullBootstrapVersion < '4.0.0') {\n        console.warn('\"centerVertical\" requires Bootstrap 4.0.0-beta.3 or higher. You appear to be using ' + options.fullBootstrapVersion + '. Please upgrade to use this option.');\n      }\n\n      innerDialog.addClass('modal-dialog-centered');\n    } // Bootstrap event listeners; these handle extra\n    // setup & teardown required after the underlying\n    // modal has performed certain actions.\n    // make sure we unbind any listeners once the dialog has definitively been dismissed\n\n\n    dialog.one('hide.bs.modal', function (e) {\n      if (e.target === this) {\n        dialog.off('escape.close.bb');\n        dialog.off('click');\n      }\n    });\n    dialog.one('hidden.bs.modal', function (e) {\n      // ensure we don't accidentally intercept hidden events triggered\n      // by children of the current dialog. We shouldn't need to handle this anymore, \n      // now that Bootstrap namespaces its events, but still worth doing.\n      if (e.target === this) {\n        dialog.remove();\n      }\n    });\n    dialog.one('shown.bs.modal', function () {\n      dialog.find('.bootbox-accept:first').trigger('focus');\n    }); // Bootbox event listeners; used to decouple some\n    // behaviours from their respective triggers\n\n    if (options.backdrop !== 'static') {\n      // A boolean true/false according to the Bootstrap docs\n      // should show a dialog the user can dismiss by clicking on\n      // the background.\n      // We always only ever pass static/false to the actual\n      // $.modal function because with \"true\" we can't trap\n      // this event (the .modal-backdrop swallows it)\n      // However, we still want to sort of respect true\n      // and invoke the escape mechanism instead\n      dialog.on('click.dismiss.bs.modal', function (e) {\n        // @NOTE: the target varies in >= 3.3.x releases since the modal backdrop\n        // moved *inside* the outer dialog rather than *alongside* it\n        if (dialog.children('.modal-backdrop').length) {\n          e.currentTarget = dialog.children('.modal-backdrop').get(0);\n        }\n\n        if (e.target !== e.currentTarget) {\n          return;\n        }\n\n        dialog.trigger('escape.close.bb');\n      });\n    }\n\n    dialog.on('escape.close.bb', function (e) {\n      // the if statement looks redundant but it isn't; without it\n      // if we *didn't* have an onEscape handler then processCallback\n      // would automatically dismiss the dialog\n      if (callbacks.onEscape) {\n        processCallback(e, dialog, callbacks.onEscape);\n      }\n    });\n    dialog.on('click', '.modal-footer button:not(.disabled)', function (e) {\n      var callbackKey = $(this).data('bb-handler');\n\n      if (callbackKey !== undefined) {\n        // Only process callbacks for buttons we recognize:\n        processCallback(e, dialog, callbacks[callbackKey]);\n      }\n    });\n    dialog.on('click', '.bootbox-close-button', function (e) {\n      // onEscape might be falsy but that's fine; the fact is\n      // if the user has managed to click the close button we\n      // have to close the dialog, callback or not\n      processCallback(e, dialog, callbacks.onEscape);\n    });\n    dialog.on('keyup', function (e) {\n      if (e.which === 27) {\n        dialog.trigger('escape.close.bb');\n      }\n    }); // the remainder of this method simply deals with adding our\n    // dialogent to the DOM, augmenting it with Bootstrap's modal\n    // functionality and then giving the resulting object back\n    // to our caller\n\n    $(options.container).append(dialog);\n    dialog.modal({\n      backdrop: options.backdrop ? 'static' : false,\n      keyboard: false,\n      show: false\n    });\n\n    if (options.show) {\n      dialog.modal('show');\n    }\n\n    return dialog;\n  }; // Helper function to simulate the native alert() behavior. **NOTE**: This is non-blocking, so any\n  // code that must happen after the alert is dismissed should be placed within the callback function \n  // for this alert.\n\n\n  exports.alert = function () {\n    var options;\n    options = mergeDialogOptions('alert', ['ok'], ['message', 'callback'], arguments); // @TODO: can this move inside exports.dialog when we're iterating over each\n    // button and checking its button.callback value instead?\n\n    if (options.callback && !$.isFunction(options.callback)) {\n      throw new Error('alert requires the \"callback\" property to be a function when provided');\n    } // override the ok and escape callback to make sure they just invoke\n    // the single user-supplied one (if provided)\n\n\n    options.buttons.ok.callback = options.onEscape = function () {\n      if ($.isFunction(options.callback)) {\n        return options.callback.call(this);\n      }\n\n      return true;\n    };\n\n    return exports.dialog(options);\n  }; // Helper function to simulate the native confirm() behavior. **NOTE**: This is non-blocking, so any\n  // code that must happen after the confirm is dismissed should be placed within the callback function \n  // for this confirm.\n\n\n  exports.confirm = function () {\n    var options;\n    options = mergeDialogOptions('confirm', ['cancel', 'confirm'], ['message', 'callback'], arguments); // confirm specific validation; they don't make sense without a callback so make\n    // sure it's present\n\n    if (!$.isFunction(options.callback)) {\n      throw new Error('confirm requires a callback');\n    } // overrides; undo anything the user tried to set they shouldn't have\n\n\n    options.buttons.cancel.callback = options.onEscape = function () {\n      return options.callback.call(this, false);\n    };\n\n    options.buttons.confirm.callback = function () {\n      return options.callback.call(this, true);\n    };\n\n    return exports.dialog(options);\n  }; // Helper function to simulate the native prompt() behavior. **NOTE**: This is non-blocking, so any\n  // code that must happen after the prompt is dismissed should be placed within the callback function \n  // for this prompt.\n\n\n  exports.prompt = function () {\n    var options;\n    var promptDialog;\n    var form;\n    var input;\n    var shouldShow;\n    var inputOptions; // we have to create our form first otherwise\n    // its value is undefined when gearing up our options\n    // @TODO this could be solved by allowing message to\n    // be a function instead...\n\n    form = $(templates.form); // prompt defaults are more complex than others in that\n    // users can override more defaults\n\n    options = mergeDialogOptions('prompt', ['cancel', 'confirm'], ['title', 'callback'], arguments);\n\n    if (!options.value) {\n      options.value = defaults.value;\n    }\n\n    if (!options.inputType) {\n      options.inputType = defaults.inputType;\n    } // capture the user's show value; we always set this to false before\n    // spawning the dialog to give us a chance to attach some handlers to\n    // it, but we need to make sure we respect a preference not to show it\n\n\n    shouldShow = options.show === undefined ? defaults.show : options.show; // This is required prior to calling the dialog builder below - we need to \n    // add an event handler just before the prompt is shown\n\n    options.show = false; // Handles the 'cancel' action\n\n    options.buttons.cancel.callback = options.onEscape = function () {\n      return options.callback.call(this, null);\n    }; // Prompt submitted - extract the prompt value. This requires a bit of work, \n    // given the different input types available.\n\n\n    options.buttons.confirm.callback = function () {\n      var value;\n\n      if (options.inputType === 'checkbox') {\n        value = input.find('input:checked').map(function () {\n          return $(this).val();\n        }).get();\n      } else if (options.inputType === 'radio') {\n        value = input.find('input:checked').val();\n      } else {\n        if (input[0].checkValidity && !input[0].checkValidity()) {\n          // prevents button callback from being called\n          return false;\n        } else {\n          if (options.inputType === 'select' && options.multiple === true) {\n            value = input.find('option:selected').map(function () {\n              return $(this).val();\n            }).get();\n          } else {\n            value = input.val();\n          }\n        }\n      }\n\n      return options.callback.call(this, value);\n    }; // prompt-specific validation\n\n\n    if (!options.title) {\n      throw new Error('prompt requires a title');\n    }\n\n    if (!$.isFunction(options.callback)) {\n      throw new Error('prompt requires a callback');\n    }\n\n    if (!templates.inputs[options.inputType]) {\n      throw new Error('Invalid prompt type');\n    } // create the input based on the supplied type\n\n\n    input = $(templates.inputs[options.inputType]);\n\n    switch (options.inputType) {\n      case 'text':\n      case 'textarea':\n      case 'email':\n      case 'password':\n        input.val(options.value);\n\n        if (options.placeholder) {\n          input.attr('placeholder', options.placeholder);\n        }\n\n        if (options.pattern) {\n          input.attr('pattern', options.pattern);\n        }\n\n        if (options.maxlength) {\n          input.attr('maxlength', options.maxlength);\n        }\n\n        if (options.required) {\n          input.prop({\n            'required': true\n          });\n        }\n\n        if (options.rows && !isNaN(parseInt(options.rows))) {\n          if (options.inputType === 'textarea') {\n            input.attr({\n              'rows': options.rows\n            });\n          }\n        }\n\n        break;\n\n      case 'date':\n      case 'time':\n      case 'number':\n      case 'range':\n        input.val(options.value);\n\n        if (options.placeholder) {\n          input.attr('placeholder', options.placeholder);\n        }\n\n        if (options.pattern) {\n          input.attr('pattern', options.pattern);\n        }\n\n        if (options.required) {\n          input.prop({\n            'required': true\n          });\n        } // These input types have extra attributes which affect their input validation.\n        // Warning: For most browsers, date inputs are buggy in their implementation of 'step', so \n        // this attribute will have no effect. Therefore, we don't set the attribute for date inputs.\n        // @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date#Setting_maximum_and_minimum_dates\n\n\n        if (options.inputType !== 'date') {\n          if (options.step) {\n            if (options.step === 'any' || !isNaN(options.step) && parseInt(options.step) > 0) {\n              input.attr('step', options.step);\n            } else {\n              throw new Error('\"step\" must be a valid positive number or the value \"any\". See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-step for more information.');\n            }\n          }\n        }\n\n        if (minAndMaxAreValid(options.inputType, options.min, options.max)) {\n          if (options.min !== undefined) {\n            input.attr('min', options.min);\n          }\n\n          if (options.max !== undefined) {\n            input.attr('max', options.max);\n          }\n        }\n\n        break;\n\n      case 'select':\n        var groups = {};\n        inputOptions = options.inputOptions || [];\n\n        if (!$.isArray(inputOptions)) {\n          throw new Error('Please pass an array of input options');\n        }\n\n        if (!inputOptions.length) {\n          throw new Error('prompt with \"inputType\" set to \"select\" requires at least one option');\n        } // placeholder is not actually a valid attribute for select,\n        // but we'll allow it, assuming it might be used for a plugin\n\n\n        if (options.placeholder) {\n          input.attr('placeholder', options.placeholder);\n        }\n\n        if (options.required) {\n          input.prop({\n            'required': true\n          });\n        }\n\n        if (options.multiple) {\n          input.prop({\n            'multiple': true\n          });\n        }\n\n        each(inputOptions, function (_, option) {\n          // assume the element to attach to is the input...\n          var elem = input;\n\n          if (option.value === undefined || option.text === undefined) {\n            throw new Error('each option needs a \"value\" property and a \"text\" property');\n          } // ... but override that element if this option sits in a group\n\n\n          if (option.group) {\n            // initialise group if necessary\n            if (!groups[option.group]) {\n              groups[option.group] = $('<optgroup />').attr('label', option.group);\n            }\n\n            elem = groups[option.group];\n          }\n\n          var o = $(templates.option);\n          o.attr('value', option.value).text(option.text);\n          elem.append(o);\n        });\n        each(groups, function (_, group) {\n          input.append(group);\n        }); // safe to set a select's value as per a normal input\n\n        input.val(options.value);\n        break;\n\n      case 'checkbox':\n        var checkboxValues = $.isArray(options.value) ? options.value : [options.value];\n        inputOptions = options.inputOptions || [];\n\n        if (!inputOptions.length) {\n          throw new Error('prompt with \"inputType\" set to \"checkbox\" requires at least one option');\n        } // checkboxes have to nest within a containing element, so\n        // they break the rules a bit and we end up re-assigning\n        // our 'input' element to this container instead\n\n\n        input = $('<div class=\"bootbox-checkbox-list\"></div>');\n        each(inputOptions, function (_, option) {\n          if (option.value === undefined || option.text === undefined) {\n            throw new Error('each option needs a \"value\" property and a \"text\" property');\n          }\n\n          var checkbox = $(templates.inputs[options.inputType]);\n          checkbox.find('input').attr('value', option.value);\n          checkbox.find('label').append('\\n' + option.text); // we've ensured values is an array so we can always iterate over it\n\n          each(checkboxValues, function (_, value) {\n            if (value === option.value) {\n              checkbox.find('input').prop('checked', true);\n            }\n          });\n          input.append(checkbox);\n        });\n        break;\n\n      case 'radio':\n        // Make sure that value is not an array (only a single radio can ever be checked)\n        if (options.value !== undefined && $.isArray(options.value)) {\n          throw new Error('prompt with \"inputType\" set to \"radio\" requires a single, non-array value for \"value\"');\n        }\n\n        inputOptions = options.inputOptions || [];\n\n        if (!inputOptions.length) {\n          throw new Error('prompt with \"inputType\" set to \"radio\" requires at least one option');\n        } // Radiobuttons have to nest within a containing element, so\n        // they break the rules a bit and we end up re-assigning\n        // our 'input' element to this container instead\n\n\n        input = $('<div class=\"bootbox-radiobutton-list\"></div>'); // Radiobuttons should always have an initial checked input checked in a \"group\".\n        // If value is undefined or doesn't match an input option, select the first radiobutton\n\n        var checkFirstRadio = true;\n        each(inputOptions, function (_, option) {\n          if (option.value === undefined || option.text === undefined) {\n            throw new Error('each option needs a \"value\" property and a \"text\" property');\n          }\n\n          var radio = $(templates.inputs[options.inputType]);\n          radio.find('input').attr('value', option.value);\n          radio.find('label').append('\\n' + option.text);\n\n          if (options.value !== undefined) {\n            if (option.value === options.value) {\n              radio.find('input').prop('checked', true);\n              checkFirstRadio = false;\n            }\n          }\n\n          input.append(radio);\n        });\n\n        if (checkFirstRadio) {\n          input.find('input[type=\"radio\"]').first().prop('checked', true);\n        }\n\n        break;\n    } // now place it in our form\n\n\n    form.append(input);\n    form.on('submit', function (e) {\n      e.preventDefault(); // Fix for SammyJS (or similar JS routing library) hijacking the form post.\n\n      e.stopPropagation(); // @TODO can we actually click *the* button object instead?\n      // e.g. buttons.confirm.click() or similar\n\n      promptDialog.find('.bootbox-accept').trigger('click');\n    });\n\n    if ($.trim(options.message) !== '') {\n      // Add the form to whatever content the user may have added.\n      var message = $(templates.promptMessage).html(options.message);\n      form.prepend(message);\n      options.message = form;\n    } else {\n      options.message = form;\n    } // Generate the dialog\n\n\n    promptDialog = exports.dialog(options); // clear the existing handler focusing the submit button...\n\n    promptDialog.off('shown.bs.modal'); // ...and replace it with one focusing our input, if possible\n\n    promptDialog.on('shown.bs.modal', function () {\n      // need the closure here since input isn't\n      // an object otherwise\n      input.focus();\n    });\n\n    if (shouldShow === true) {\n      promptDialog.modal('show');\n    }\n\n    return promptDialog;\n  }; // INTERNAL FUNCTIONS\n  // *************************************************************************************************************\n  // Map a flexible set of arguments into a single returned object\n  // If args.length is already one just return it, otherwise\n  // use the properties argument to map the unnamed args to\n  // object properties.\n  // So in the latter case:\n  //  mapArguments([\"foo\", $.noop], [\"message\", \"callback\"])\n  //  -> { message: \"foo\", callback: $.noop }\n\n\n  function mapArguments(args, properties) {\n    var argn = args.length;\n    var options = {};\n\n    if (argn < 1 || argn > 2) {\n      throw new Error('Invalid argument length');\n    }\n\n    if (argn === 2 || typeof args[0] === 'string') {\n      options[properties[0]] = args[0];\n      options[properties[1]] = args[1];\n    } else {\n      options = args[0];\n    }\n\n    return options;\n  } //  Merge a set of default dialog options with user supplied arguments\n\n\n  function mergeArguments(defaults, args, properties) {\n    return $.extend( // deep merge\n    true, // ensure the target is an empty, unreferenced object\n    {}, // the base options object for this type of dialog (often just buttons)\n    defaults, // args could be an object or array; if it's an array properties will\n    // map it to a proper options object\n    mapArguments(args, properties));\n  } //  This entry-level method makes heavy use of composition to take a simple\n  //  range of inputs and return valid options suitable for passing to bootbox.dialog\n\n\n  function mergeDialogOptions(className, labels, properties, args) {\n    var locale;\n\n    if (args && args[0]) {\n      locale = args[0].locale || defaults.locale;\n      var swapButtons = args[0].swapButtonOrder || defaults.swapButtonOrder;\n\n      if (swapButtons) {\n        labels = labels.reverse();\n      }\n    } //  build up a base set of dialog properties\n\n\n    var baseOptions = {\n      className: 'bootbox-' + className,\n      buttons: createLabels(labels, locale)\n    }; // Ensure the buttons properties generated, *after* merging\n    // with user args are still valid against the supplied labels\n\n    return validateButtons( // merge the generated base properties with user supplied arguments\n    mergeArguments(baseOptions, args, // if args.length > 1, properties specify how each arg maps to an object key\n    properties), labels);\n  } //  Checks each button object to see if key is valid. \n  //  This function will only be called by the alert, confirm, and prompt helpers. \n\n\n  function validateButtons(options, buttons) {\n    var allowedButtons = {};\n    each(buttons, function (key, value) {\n      allowedButtons[value] = true;\n    });\n    each(options.buttons, function (key) {\n      if (allowedButtons[key] === undefined) {\n        throw new Error('button key \"' + key + '\" is not allowed (options are ' + buttons.join(' ') + ')');\n      }\n    });\n    return options;\n  } //  From a given list of arguments, return a suitable object of button labels.\n  //  All this does is normalise the given labels and translate them where possible.\n  //  e.g. \"ok\", \"confirm\" -> { ok: \"OK\", cancel: \"Annuleren\" }\n\n\n  function createLabels(labels, locale) {\n    var buttons = {};\n\n    for (var i = 0, j = labels.length; i < j; i++) {\n      var argument = labels[i];\n      var key = argument.toLowerCase();\n      var value = argument.toUpperCase();\n      buttons[key] = {\n        label: getText(value, locale)\n      };\n    }\n\n    return buttons;\n  } //  Get localized text from a locale. Defaults to 'en' locale if no locale \n  //  provided or a non-registered locale is requested\n\n\n  function getText(key, locale) {\n    var labels = locales[locale];\n    return labels ? labels[key] : locales.en[key];\n  } //  Filter and tidy up any user supplied parameters to this dialog.\n  //  Also looks for any shorthands used and ensures that the options\n  //  which are returned are all normalized properly\n\n\n  function sanitize(options) {\n    var buttons;\n    var total;\n\n    if (typeof options !== 'object') {\n      throw new Error('Please supply an object of options');\n    }\n\n    if (!options.message) {\n      throw new Error('\"message\" option must not be null or an empty string.');\n    } // make sure any supplied options take precedence over defaults\n\n\n    options = $.extend({}, defaults, options); // no buttons is still a valid dialog but it's cleaner to always have\n    // a buttons object to iterate over, even if it's empty\n\n    if (!options.buttons) {\n      options.buttons = {};\n    }\n\n    buttons = options.buttons;\n    total = getKeyLength(buttons);\n    each(buttons, function (key, button, index) {\n      if ($.isFunction(button)) {\n        // short form, assume value is our callback. Since button\n        // isn't an object it isn't a reference either so re-assign it\n        button = buttons[key] = {\n          callback: button\n        };\n      } // before any further checks make sure by now button is the correct type\n\n\n      if ($.type(button) !== 'object') {\n        throw new Error('button with key \"' + key + '\" must be an object');\n      }\n\n      if (!button.label) {\n        // the lack of an explicit label means we'll assume the key is good enough\n        button.label = key;\n      }\n\n      if (!button.className) {\n        var isPrimary = false;\n\n        if (options.swapButtonOrder) {\n          isPrimary = index === 0;\n        } else {\n          isPrimary = index === total - 1;\n        }\n\n        if (total <= 2 && isPrimary) {\n          // always add a primary to the main option in a one or two-button dialog\n          button.className = 'btn-primary';\n        } else {\n          // adding both classes allows us to target both BS3 and BS4 without needing to check the version\n          button.className = 'btn-secondary btn-default';\n        }\n      }\n    });\n    return options;\n  } //  Returns a count of the properties defined on the object\n\n\n  function getKeyLength(obj) {\n    return Object.keys(obj).length;\n  } //  Tiny wrapper function around jQuery.each; just adds index as the third parameter\n\n\n  function each(collection, iterator) {\n    var index = 0;\n    $.each(collection, function (key, value) {\n      iterator(key, value, index++);\n    });\n  } //  Handle the invoked dialog callback\n\n\n  function processCallback(e, dialog, callback) {\n    e.stopPropagation();\n    e.preventDefault(); // by default we assume a callback will get rid of the dialog,\n    // although it is given the opportunity to override this\n    // so, if the callback can be invoked and it *explicitly returns false*\n    // then we'll set a flag to keep the dialog active...\n\n    var preserveDialog = $.isFunction(callback) && callback.call(dialog, e) === false; // ... otherwise we'll bin it\n\n    if (!preserveDialog) {\n      dialog.modal('hide');\n    }\n  } // Validate `min` and `max` values based on the current `inputType` value\n\n\n  function minAndMaxAreValid(type, min, max) {\n    var result = false;\n    var minValid = true;\n    var maxValid = true;\n\n    if (type === 'date') {\n      if (min !== undefined && !(minValid = dateIsValid(min))) {\n        console.warn('Browsers which natively support the \"date\" input type expect date values to be of the form \"YYYY-MM-DD\" (see ISO-8601 https://www.iso.org/iso-8601-date-and-time-format.html). Bootbox does not enforce this rule, but your min value may not be enforced by this browser.');\n      } else if (max !== undefined && !(maxValid = dateIsValid(max))) {\n        console.warn('Browsers which natively support the \"date\" input type expect date values to be of the form \"YYYY-MM-DD\" (see ISO-8601 https://www.iso.org/iso-8601-date-and-time-format.html). Bootbox does not enforce this rule, but your max value may not be enforced by this browser.');\n      }\n    } else if (type === 'time') {\n      if (min !== undefined && !(minValid = timeIsValid(min))) {\n        throw new Error('\"min\" is not a valid time. See https://www.w3.org/TR/2012/WD-html-markup-20120315/datatypes.html#form.data.time for more information.');\n      } else if (max !== undefined && !(maxValid = timeIsValid(max))) {\n        throw new Error('\"max\" is not a valid time. See https://www.w3.org/TR/2012/WD-html-markup-20120315/datatypes.html#form.data.time for more information.');\n      }\n    } else {\n      if (min !== undefined && isNaN(min)) {\n        throw new Error('\"min\" must be a valid number. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-min for more information.');\n      }\n\n      if (max !== undefined && isNaN(max)) {\n        throw new Error('\"max\" must be a valid number. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-max for more information.');\n      }\n    }\n\n    if (minValid && maxValid) {\n      if (max <= min) {\n        throw new Error('\"max\" must be greater than \"min\". See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-max for more information.');\n      } else {\n        result = true;\n      }\n    }\n\n    return result;\n  }\n\n  function timeIsValid(value) {\n    return /([01][0-9]|2[0-3]):[0-5][0-9]?:[0-5][0-9]/.test(value);\n  }\n\n  function dateIsValid(value) {\n    return /(\\d{4})-(\\d{2})-(\\d{2})/.test(value);\n  } //  Register the default locale\n\n\n  exports.addLocale('en', {\n    OK: 'OK',\n    CANCEL: 'Cancel',\n    CONFIRM: 'OK'\n  }); //  The Bootbox object\n\n  return exports;\n});","map":null,"metadata":{},"sourceType":"script"}